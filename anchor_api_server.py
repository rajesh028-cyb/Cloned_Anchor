# ANCHOR API Server - GUVI Agentic HoneyPot API Specification
# Production-ready HTTP server for hackathon submission (STATELESS)

"""
ANCHOR API Server - GUVI HoneyPot Compliant (Stateless)
========================================================
Flask-based HTTP server compliant with GUVI Agentic HoneyPot API specification.

STATELESS DESIGN:
- Each request creates a fresh agent
- conversationHistory is used to reconstruct state
- No reliance on server-side memory persistence

Endpoints:
- POST /process     - Process scammer message (GUVI format)
- POST /reset       - Reset session (no-op in stateless mode)
- GET  /health      - Health check

Request Format:
{
    "sessionId": "<session identifier>",
    "message": {
        "text": "<scammer message>",
        "sender": "<sender id>",
        "timestamp": "<ISO timestamp>"
    },
    "conversationHistory": [
        {"sender": "scammer", "text": "...", "timestamp": ...},
        {"sender": "agent", "text": "...", "timestamp": ...},
        ...
    ],
    "metadata": {...}
}

Response Format:
{
    "status": "success",
    "reply": "<agent response>"
}
"""

import logging
import os
import requests

try:
    from flask import Flask, request, jsonify
    FLASK_AVAILABLE = True
except ImportError:
    FLASK_AVAILABLE = False

from anchor_agent import AnchorAgent, create_agent
from extractor import create_extractor
from dotenv import load_dotenv
load_dotenv()


# Track sessions: session_id -> intel_count at last callback
_session_last_intel = {}

# GUVI Final Result Endpoint
GUVI_FINAL_RESULT_URL = "https://hackathon.guvi.in/api/updateHoneyPotFinalResult"

def rebuild_agent_from_history(agent, history):
    """
    Reconstruct ONLY memory (artifacts + scammer turn count) from GUVI conversationHistory.
    
    IMPORTANT: Do NOT touch the state machine here!
    - The state machine depends on exact agent replies originally generated by Anchor
    - GUVI only sends back plain text, not internal context
    - Replaying history through analyze_and_transition corrupts state machine timeline
    
    We only extract TWO things from history:
    1. Cumulative artifacts (from scammer messages)
    2. Scammer turn count
    
    The real state machine runs ONLY for the current message via process_api_message().
    """
    extractor = create_extractor()
    
    # Reset ONLY memory, NOT state machine
    agent.memory.reset()
    
    for msg in history:
        text = msg.get("text", "")
        sender = msg.get("sender", "").lower()
        
        if not text:
            continue
        
        if sender == "scammer":
            # 1. Extract artifacts from historical scammer message
            artifacts = extractor.extract(text)
            
            # 2. Merge artifacts into cumulative store
            if artifacts.has_artifacts():
                agent.memory.cumulative_artifacts.merge(artifacts)
            
            # 3. Increment scammer turn count
            agent.memory.metrics.scammer_turns += 1
        
        # Ignore "agent" and "user" messages - we only need artifacts and turn count


def count_scammer_turns(conversation_history: list) -> int:
    """Count number of scammer messages in history"""
    return sum(1 for msg in conversation_history if msg.get("sender", "").lower() == "scammer")


def send_final_callback(session_id: str, agent, scam_detected: bool, suspicious_keywords: list):
    """
    Submit final intelligence to GUVI endpoint.
    Called when intelligence is extracted and turns >= 8.
    """
    try:
        artifacts = agent.memory.get_all_artifacts()
        total_turns = agent.memory.metrics.scammer_turns
        
        intelligence = {
            "bankAccounts": artifacts.get("bank_accounts", []),
            "upiIds": artifacts.get("upi_ids", []),
            "phishingLinks": artifacts.get("phishing_links", []),
            "phoneNumbers": artifacts.get("phone_numbers", []),
            "suspiciousKeywords": suspicious_keywords
        }
        
        payload = {
            "sessionId": session_id,
            "scamDetected": scam_detected,
            "totalMessagesExchanged": total_turns,
            "extractedIntelligence": intelligence,
            "agentNotes": "Autonomous engagement completed. Intelligence extracted via deception."
        }
        
        print(f"\nðŸ”” CALLBACK TRIGGERED: Session {session_id}")
        print(f"   Turns: {total_turns}")
        print(f"   UPI IDs: {len(intelligence['upiIds'])}")
        print(f"   Bank Accounts: {len(intelligence['bankAccounts'])}")
        print(f"   Phishing Links: {len(intelligence['phishingLinks'])}")
        print(f"   Phone Numbers: {len(intelligence['phoneNumbers'])}")
        
        response = requests.post(
            GUVI_FINAL_RESULT_URL,
            json=payload,
            timeout=5
        )
        print(f"   GUVI Response: {response.status_code}")
        
    except Exception as e:
        print(f"   âš ï¸ Callback error: {str(e)}")


def require_api_key():
    """Check API key and return error response if invalid"""
    api_key = request.headers.get("x-api-key")
    expected_key = os.getenv("ANCHOR_API_KEY", "anchor-secret")
    
    if api_key != expected_key:
        return jsonify({"status": "error", "reply": ""}), 401
    return None


if FLASK_AVAILABLE:
    app = Flask(__name__)
    
    # Suppress all Flask logging for clean output
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)
    logging.getLogger('flask').setLevel(logging.ERROR)
    
    @app.route('/health', methods=['GET'])
    def health():
        """Health check endpoint"""
        return jsonify({
            "status": "healthy",
            "service": "ANCHOR HoneyPot API",
            "version": "2.1.0-stateless"
        })
    
    @app.route('/process', methods=['POST'])
    def process():
        """
        Process scammer message - GUVI HoneyPot API compliant (STATELESS).
        
        Reconstructs BOTH memory AND state machine from conversationHistory
        without replaying messages through the agent.
        """
        auth_error = require_api_key()
        if auth_error:
            return auth_error
        
        try:
            data = request.get_json()
            
            if not data:
                return jsonify({"status": "error", "reply": ""}), 200
            
            # Extract fields from GUVI format
            session_id = data.get("sessionId", "default")
            conversation_history = data.get("conversationHistory", [])
            
            # Extract current message
            message_obj = data.get("message", {})
            message_text = message_obj.get("text", "") if isinstance(message_obj, dict) else ""
            
            if not message_text:
                return jsonify({"status": "success", "reply": ""})
            
            # STATELESS: Create fresh agent for this request
            agent = create_agent(session_id)
            
            # Rebuild memory AND state machine from history (no LLM calls)
            rebuild_agent_from_history(agent, conversation_history)
            
            # Process ONLY the current message through the agent
            result = agent.process_api_message({
                "message": message_text,
                "session_id": session_id
            })
            
            # Extract response
            agent_response = result.get("response", "")
            
            # âœ… Read cumulative state from memory, not result
            artifacts = agent.memory.get_all_artifacts()
            turns = agent.memory.metrics.scammer_turns
            
            # â”€â”€ Scam Detection + Keyword Extraction (all scammer messages) â”€â”€
            scammer_texts = [
                msg.get("text", "") for msg in conversation_history
                if msg.get("sender", "").lower() == "scammer"
            ]
            scammer_texts.append(message_text)
            
            all_keywords = set()
            for text in scammer_texts:
                all_keywords.update(agent.extractor.extract_suspicious_keywords(text))
            suspicious_keywords = sorted(all_keywords)
            
            # Scam detected if any suspicious keywords found (latches via history)
            scam_detected = len(suspicious_keywords) > 0
            
            # â”€â”€ Callback: fire when turns >= 8 and new intel available â”€â”€
            intel_count = (
                len(artifacts.get("upi_ids", [])) +
                len(artifacts.get("bank_accounts", [])) +
                len(artifacts.get("phishing_links", [])) +
                len(artifacts.get("phone_numbers", [])) +
                len(suspicious_keywords)
            )
            has_intel = intel_count > 0
            last_count = _session_last_intel.get(session_id, 0)
            
            if has_intel and turns >= 8 and intel_count > last_count:
                send_final_callback(session_id, agent, scam_detected, suspicious_keywords)
                _session_last_intel[session_id] = intel_count
            
            # Return clean GUVI-compliant response
            return jsonify({
                "status": "success",
                "reply": agent_response
            })
            
        except Exception:
            # Always return 200 with clean response structure
            return jsonify({"status": "success", "reply": ""})
    
    @app.route('/reset', methods=['POST'])
    def reset():
        """Reset session - clears callback tracking"""
        auth_error = require_api_key()
        if auth_error:
            return auth_error
        
        try:
            data = request.get_json() or {}
            session_id = data.get("sessionId", data.get("session_id", "default"))
            
            # Clear callback tracking to allow new callback
            _session_last_intel.pop(session_id, None)
            
            return jsonify({"status": "success"})
                
        except Exception:
            return jsonify({"status": "success"})
    
    @app.route('/sessions', methods=['GET'])
    def list_sessions():
        """List completed sessions"""
        auth_error = require_api_key()
        if auth_error:
            return auth_error
        
        return jsonify({
            "status": "success",
            "completed_callbacks": len(_session_last_intel)
        })


# Change this line in anchor_api_server.py
def run_server(host: str = "0.0.0.0", port: int = 8080, debug: bool = False):
    """
    Run ANCHOR API server.
    
    Args:
        host: Bind address
        port: Port number
        debug: Enable debug mode
    """
    if not FLASK_AVAILABLE:
        print("ERROR: Flask not installed. Run: pip install flask")
        return
    
    print(f"ANCHOR HoneyPot API (Stateless) running on http://{host}:{port}")
    
    app.run(host=host, port=port, debug=debug, use_reloader=False)


if __name__ == "__main__":
    import sys
    
    port = 8080
    if len(sys.argv) > 1:
        try:
            port = int(sys.argv[1])
        except ValueError:
            pass
    
    run_server(port=port, debug=False)
