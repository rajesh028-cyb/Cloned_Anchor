# ANCHOR API Server - GUVI Agentic HoneyPot API Specification
# Production-ready HTTP server for hackathon submission (STATELESS)

"""
ANCHOR API Server - GUVI HoneyPot Compliant (Stateless)
========================================================
Flask-based HTTP server compliant with GUVI Agentic HoneyPot API specification.

STATELESS DESIGN:
- Each request creates a fresh agent
- conversationHistory is used to reconstruct state
- No reliance on server-side memory persistence

Endpoints:
- POST /process     - Process scammer message (GUVI format)
- POST /reset       - Reset session (no-op in stateless mode)
- GET  /health      - Health check

Request Format:
{
    "sessionId": "<session identifier>",
    "message": {
        "text": "<scammer message>",
        "sender": "<sender id>",
        "timestamp": "<ISO timestamp>"
    },
    "conversationHistory": [
        {"sender": "scammer", "text": "...", "timestamp": ...},
        {"sender": "agent", "text": "...", "timestamp": ...},
        ...
    ],
    "metadata": {...}
}

Response Format:
{
    "status": "success",
    "reply": "<agent response>"
}
"""

import logging
import os
import requests

try:
    from flask import Flask, request, jsonify
    FLASK_AVAILABLE = True
except ImportError:
    FLASK_AVAILABLE = False

from anchor_agent import AnchorAgent, create_agent
from extractor import create_extractor
from osint_enricher import get_enricher as get_osint_enricher
from dotenv import load_dotenv
load_dotenv()

# ‚îÄ‚îÄ SAFE MODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
SAFE_MODE = os.getenv("ANCHOR_SAFE_MODE", "0") == "1"

# ‚îÄ‚îÄ SURVIVAL RESPONSES (deterministic, in-character, never silent) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
SURVIVAL_RESPONSES = [
    "Hello? Is someone there? The line is very bad.",
    "I'm sorry, I couldn't hear that. Can you say it again?",
    "One moment dear, I need to adjust my hearing aid.",
    "Hmm, the phone is making strange noises. Are you still there?",
    "I think we got disconnected for a second. What were you saying?",
]
_survival_counter = 0

def get_survival_reply() -> str:
    """Deterministic in-character fallback. NEVER returns empty."""
    global _survival_counter
    reply = SURVIVAL_RESPONSES[_survival_counter % len(SURVIVAL_RESPONSES)]
    _survival_counter += 1
    return reply


# Track sessions: session_id -> intel_count at last callback
_session_last_intel = {}

# GUVI Final Result Endpoint
GUVI_FINAL_RESULT_URL = "https://hackathon.guvi.in/api/updateHoneyPotFinalResult"

def rebuild_agent_from_history(agent, history):
    """
    Reconstruct ONLY memory (artifacts + scammer turn count) from GUVI conversationHistory.
    
    IMPORTANT: Do NOT touch the state machine here!
    - The state machine depends on exact agent replies originally generated by Anchor
    - GUVI only sends back plain text, not internal context
    - Replaying history through analyze_and_transition corrupts state machine timeline
    
    We only extract TWO things from history:
    1. Cumulative artifacts (from scammer messages)
    2. Scammer turn count
    
    The real state machine runs ONLY for the current message via process_api_message().
    """
    extractor = create_extractor()
    
    # Reset ONLY memory, NOT state machine
    agent.memory.reset()
    
    for msg in history:
        text = msg.get("text", "")
        sender = msg.get("sender", "").lower()
        
        if not text:
            continue
        
        if sender == "scammer":
            # 1. Extract artifacts from historical scammer message
            artifacts = extractor.extract(text)
            
            # 2. Merge artifacts into cumulative store
            if artifacts.has_artifacts():
                agent.memory.cumulative_artifacts.merge(artifacts)
            
            # 3. Increment scammer turn count
            agent.memory.metrics.scammer_turns += 1
        
        # Ignore "agent" and "user" messages - we only need artifacts and turn count


def count_scammer_turns(conversation_history: list) -> int:
    """Count number of scammer messages in history"""
    return sum(1 for msg in conversation_history if msg.get("sender", "").lower() == "scammer")


def send_final_callback(session_id: str, agent, scam_detected: bool, suspicious_keywords: list):
    """
    Submit final intelligence to GUVI endpoint.
    Called when intelligence is extracted and turns >= 3.
    In SAFE_MODE, logs but does NOT make the HTTP call.
    """
    try:
        artifacts = agent.memory.get_all_artifacts()
        total_turns = agent.memory.metrics.scammer_turns
        behavior = agent.state_machine.scorer.get_summary()
        
        intelligence = {
            "bankAccounts": artifacts.get("bank_accounts", []),
            "upiIds": artifacts.get("upi_ids", []),
            "phishingLinks": artifacts.get("phishing_links", []),
            "phoneNumbers": artifacts.get("phone_numbers", []),
            "suspiciousKeywords": suspicious_keywords
        }
        
        payload = {
            "sessionId": session_id,
            "scamDetected": scam_detected,
            "totalMessagesExchanged": total_turns,
            "extractedIntelligence": intelligence,
            "behaviorScore": behavior["cumulative_score"],
            "agentNotes": "Autonomous engagement completed. Intelligence extracted via deception."
        }
        
        print(f"\nüîî CALLBACK TRIGGERED: Session {session_id}")
        print(f"   Turns: {total_turns}")
        print(f"   Behavior Score: {behavior['cumulative_score']}")
        print(f"   UPI IDs: {len(intelligence['upiIds'])}")
        print(f"   Bank Accounts: {len(intelligence['bankAccounts'])}")
        print(f"   Phishing Links: {len(intelligence['phishingLinks'])}")
        print(f"   Phone Numbers: {len(intelligence['phoneNumbers'])}")
        
        if SAFE_MODE:
            print("   üõ°Ô∏è SAFE_MODE: callback logged, HTTP skipped")
            return
        
        response = requests.post(
            GUVI_FINAL_RESULT_URL,
            json=payload,
            timeout=5
        )
        print(f"   GUVI Response: {response.status_code}")
        
    except Exception as e:
        print(f"   ‚ö†Ô∏è Callback error: {str(e)}")


def require_api_key():
    """Check API key and return error response if invalid"""
    api_key = request.headers.get("x-api-key")
    expected_key = os.getenv("ANCHOR_API_KEY", "anchor-secret")
    
    if api_key != expected_key:
        return jsonify({"status": "error", "reply": ""}), 401
    return None


if FLASK_AVAILABLE:
    app = Flask(__name__)
    
    # Suppress all Flask logging for clean output
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)
    logging.getLogger('flask').setLevel(logging.ERROR)
    
    @app.route('/health', methods=['GET'])
    def health():
        """Health check endpoint"""
        return jsonify({
            "status": "healthy",
            "service": "ANCHOR HoneyPot API",
            "version": "2.2.0-deterministic",
            "safe_mode": SAFE_MODE,
        })
    
    @app.route('/process', methods=['POST'])
    def process():
        """
        Process scammer message - GUVI HoneyPot API compliant (STATELESS).
        
        Reconstructs BOTH memory AND state machine from conversationHistory
        without replaying messages through the agent.
        """
        auth_error = require_api_key()
        if auth_error:
            return auth_error
        
        try:
            data = request.get_json()
            
            if not data:
                return jsonify({"status": "success", "reply": get_survival_reply()}), 200
            
            # Extract fields from GUVI format
            session_id = data.get("sessionId", "default")
            conversation_history = data.get("conversationHistory", [])
            
            # Extract current message
            message_obj = data.get("message", {})
            message_text = message_obj.get("text", "") if isinstance(message_obj, dict) else ""
            
            if not message_text:
                return jsonify({"status": "success", "reply": get_survival_reply()})
            
            # STATELESS: Create fresh agent for this request
            agent = create_agent(session_id)
            
            # Rebuild memory AND state machine from history (no LLM calls)
            rebuild_agent_from_history(agent, conversation_history)
            
            # Process ONLY the current message through the agent
            result = agent.process_api_message({
                "message": message_text,
                "session_id": session_id
            })
            
            # Extract response
            agent_response = result.get("response", "") or get_survival_reply()
            
            # ‚úÖ Read cumulative state from memory, not result
            artifacts = agent.memory.get_all_artifacts()
            turns = agent.memory.metrics.scammer_turns
            
            # ‚îÄ‚îÄ OSINT: Fire-and-forget post-extraction enrichment ‚îÄ‚îÄ
            # GUARANTEES:
            #   - Returns in < 0.1ms (daemon thread dispatch only)
            #   - NEVER blocks the /process response
            #   - NEVER mutates artifacts dict
            #   - Fully disabled in SAFE_MODE
            try:
                osint_enricher = get_osint_enricher()
                osint_enricher.enrich_async(
                    session_id=session_id,
                    artifacts_dict=artifacts,
                    skip_holehe=True,  # Holehe is slow ‚Äî offline/post-incident only
                )
            except Exception:
                pass  # OSINT failure is NEVER visible to the caller
            
            # ‚îÄ‚îÄ Scam Detection + Keyword Extraction (all scammer messages) ‚îÄ‚îÄ
            scammer_texts = [
                msg.get("text", "") for msg in conversation_history
                if msg.get("sender", "").lower() == "scammer"
            ]
            scammer_texts.append(message_text)
            
            all_keywords = set()
            for text in scammer_texts:
                all_keywords.update(agent.extractor.extract_suspicious_keywords(text))
            suspicious_keywords = sorted(all_keywords)
            
            # Scam detected if any suspicious keywords found (latches via history)
            scam_detected = len(suspicious_keywords) > 0
            
            # ‚îÄ‚îÄ Callback: fire when turns >= 8 and new intel available ‚îÄ‚îÄ
            intel_count = (
                len(artifacts.get("upi_ids", [])) +
                len(artifacts.get("bank_accounts", [])) +
                len(artifacts.get("phishing_links", [])) +
                len(artifacts.get("phone_numbers", [])) +
                len(suspicious_keywords)
            )
            has_intel = intel_count > 0
            last_count = _session_last_intel.get(session_id, 0)
            
            if has_intel and turns >= 3 and intel_count > last_count:
                send_final_callback(session_id, agent, scam_detected, suspicious_keywords)
                _session_last_intel[session_id] = intel_count
            
            # Return clean GUVI-compliant response
            return jsonify({
                "status": "success",
                "reply": agent_response
            })
            
        except Exception:
            # SURVIVAL: Never silent ‚Äì always in-character
            return jsonify({"status": "success", "reply": get_survival_reply()})
    
    @app.route('/reset', methods=['POST'])
    def reset():
        """Reset session - clears callback tracking"""
        auth_error = require_api_key()
        if auth_error:
            return auth_error
        
        try:
            data = request.get_json() or {}
            session_id = data.get("sessionId", data.get("session_id", "default"))
            
            # Clear callback tracking to allow new callback
            _session_last_intel.pop(session_id, None)
            
            return jsonify({"status": "success"})
                
        except Exception:
            return jsonify({"status": "success"})
    
    @app.route('/sessions', methods=['GET'])
    def list_sessions():
        """List completed sessions"""
        auth_error = require_api_key()
        if auth_error:
            return auth_error
        
        return jsonify({
            "status": "success",
            "completed_callbacks": len(_session_last_intel)
        })


# Change this line in anchor_api_server.py
def run_server(host: str = "0.0.0.0", port: int = 8080, debug: bool = False):
    """
    Run ANCHOR API server.
    
    Args:
        host: Bind address
        port: Port number
        debug: Enable debug mode
    """
    if not FLASK_AVAILABLE:
        print("ERROR: Flask not installed. Run: pip install flask")
        return
    
    print(f"ANCHOR HoneyPot API (Stateless) running on http://{host}:{port}")
    
    app.run(host=host, port=port, debug=debug, use_reloader=False)


if __name__ == "__main__":
    import sys
    
    port = 8080
    if len(sys.argv) > 1:
        try:
            port = int(sys.argv[1])
        except ValueError:
            pass
    
    run_server(port=port, debug=False)
